[{"path":"/articles/getFeature_example.html","id":"detailed-example-of-getfeature","dir":"Articles","previous_headings":"","what":"Detailed Example of getFeature","title":"Detailed Example of getFeature Usage","text":"vignette provides detailed example use getFeature function specify particular genomic features within region file, adapted rootGenomics original getFeature function. function leverages GenomicRanges package manipulation genomic data.","code":""},{"path":"/articles/getFeature_example.html","id":"prerequisites","dir":"Articles","previous_headings":"Detailed Example of getFeature","what":"Prerequisites","title":"Detailed Example of getFeature Usage","text":"begin, ensure necessary packages installed loaded:","code":"if (!require(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\") BiocManager::install(version = \"3.21\")  if (!requireNamespace(\"GenomicRanges\", quietly = TRUE)) {   BiocManager::install(\"GenomicRanges\") }  # Once installed then load the required libraries  library(GenomicRanges)"},{"path":"/articles/getFeature_example.html","id":"usage","dir":"Articles","previous_headings":"Detailed Example of getFeature","what":"Usage","title":"Detailed Example of getFeature Usage","text":"example wanting : 1. Specify region around TSS 50b flank either side 2. Specify second exon gene flank Import region file GRanges object Using getFeature specify TSS region 50b flank either side Using getFeature specify second exon","code":"# Import region file region_file <- readBed(path/to/region_file.bed) # Set start/end feature to \"TSS\" and both flanks to 50 TSSregion <- getFeature(   object = region_file,    start_feature = \"TSS\",    end_feature = \"TSS\",    start_flank = 50,    end_flank = 50   ) # Set start_feature to the 5' boundary of Exon 2 and end_feature to the 3' boundary of Exon 2 Exon2region <- getFeature(   object = region_file,    start_feature = \"Exon\",    start_exon = 2,    start_exon_boundary = \"5prime\",   end_feature = \"Exon\",   end_exon = 2,   end_exon_boundary = \"3prime   )"},{"path":"/articles/hmList_example.html","id":"detailed-example-of-hmlist","dir":"Articles","previous_headings":"","what":"Detailed Example of hmList","title":"Detailed Example of hmList Usage","text":"vignette provides detailed example use hmList function create heatmap list list matrices generated via matList function. range customisation options available alter output. function leverages EnrichedHeatmap, circlize, RColorBrewer, grdevices, stats, purrr, graphics packages handle data matrices convert attractive heatmap","code":""},{"path":"/articles/hmList_example.html","id":"prerequisites","dir":"Articles","previous_headings":"Detailed Example of hmList","what":"Prerequisites","title":"Detailed Example of hmList Usage","text":"begin, ensure necessary packages installed loaded:","code":"if (!require(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\") BiocManager::install(version = \"3.21\")  if (!requireNamespace(\"purrr\", quietly = TRUE)) {   install.packages(\"purrr\") } if (!requireNamespace(\"circlize\", quietly = TRUE)) {   install.packages(\"circlize\") } if (!requireNamespace(\"RColorBrewer\", quietly = TRUE)) {   install.packages(\"RColorBrewer\") } if (!requireNamespace(\"grDevices\", quietly = TRUE)) {   install.packages(\"grDevices\") } if (!requireNamespace(\"stats\", quietly = TRUE)) {   install.packages(\"stats\") } if (!requireNamespace(\"graphics\", quietly = TRUE)) {   install.packages(\"graphics\") } if (!requireNamespace(\"EnrichedHeatmap\", quietly = TRUE)) {   BiocManager::install(\"EnrichedHeatmap\") }  # Once installed then load the required libraries  library(purrr) library(circlize) library(RColorBrewer) library(grDevices) library(stats) library(graphics) library(EnrichedHeatmap)"},{"path":"/articles/hmList_example.html","id":"usage","dir":"Articles","previous_headings":"Detailed Example of hmList","what":"Usage","title":"Detailed Example of hmList Usage","text":"case going take list matrices called “matrixlist” generated matList function use generate heatmaps using hmList function Selecting window sizes plotting. case give 50 windows upstream flank, 100 full gene, 50 downstream flank Creating heatmaps following customisation options: (1) Blue red colour scale (2) Labels “-50b”, “TSS”, “TES,”+50b” (3) show row names","code":"# Specify the window sizes windows <- c(\"Upstream\" = 50, \"Gene\" = 100, \"Downstream\" = 50) # Generating our heatmap list heatmaps <- hmList(   matl = matrixlist,    wins = windows,    col_fun = \"bl2rd\",    show_row_names = FALSE,    win_labels = c(\"-50b\", \"TSS\", \"TES\", \"+50b\")   )"},{"path":"/articles/importBWlist_example.html","id":"detailed-example-of-importbwlist","dir":"Articles","previous_headings":"","what":"Detailed Example of importBWlist","title":"Detailed Example of importBWlist Usage","text":"vignette provides detailed example use importBWlist function efficiently import data multiple BigWig (.bw) files R. importBWlist function leverages rtracklayer package actual import purrr streamlined iteration files.","code":""},{"path":"/articles/importBWlist_example.html","id":"prerequisites","dir":"Articles","previous_headings":"Detailed Example of importBWlist","what":"Prerequisites","title":"Detailed Example of importBWlist Usage","text":"begin, ensure necessary packages installed loaded:","code":"if (!require(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\") BiocManager::install(version = \"3.21\")  if (!requireNamespace(\"rtracklayer\", quietly = TRUE)) {   BiocManager::install(\"rtracklayer\") } if (!requireNamespace(\"purrr\", quietly = TRUE)) {   install.packages(\"purrr\") } if (!requireNamespace(\"GenomicRanges\", quietly = TRUE)) {   BiocManager::install(\"GenomicRanges\") }  # Once installed then load the required libraries  library(rtracklayer) library(purrr) library(GenomicRanges)"},{"path":"/articles/importBWlist_example.html","id":"usage","dir":"Articles","previous_headings":"Detailed Example of importBWlist","what":"Usage","title":"Detailed Example of importBWlist Usage","text":"Specify file paths bigWig files want import: Define names imported objects: Import optional .bed file GRanges object specify genomic regions import bed file Now specified files, names, selection region can use importBWlist","code":"bw_file_paths <- c(   \"path/to/sample1.bw\",   \"path/to/sample2.bw\",   \"path/to/treatment.bw\" ) sample_names <- c(   \"Sample1\",   \"Sample2\",   \"Treatment\" ) regions <- readBed(path/to/regionfile.bed) imported_bw <- importBWlist(   bwf = bw_file_paths,    names = sample_names,    selection = regions   )"},{"path":"/articles/matList_example.html","id":"detailed-example-of-matlist","dir":"Articles","previous_headings":"","what":"Detailed Example of matList","title":"Detailed Example of matList Usage","text":"vignette provides detailed example use matList function generate matrices list imported bigWig files region files range customisation options alter output. function leverages rtracklayer, GenomicRanges, purrr, MatrixGenerics, EnrichedHeatmap packages manipulate genomic data process matrix.","code":""},{"path":"/articles/matList_example.html","id":"prerequisites","dir":"Articles","previous_headings":"Detailed Example of matList","what":"Prerequisites","title":"Detailed Example of matList Usage","text":"begin, ensure necessary packages installed loaded:","code":"if (!require(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\") BiocManager::install(version = \"3.21\")  if (!requireNamespace(\"rtracklayer\", quietly = TRUE)) {   BiocManager::install(\"rtracklayer\") } if (!requireNamespace(\"purrr\", quietly = TRUE)) {   install.packages(\"purrr\") } if (!requireNamespace(\"GenomicRanges\", quietly = TRUE)) {   BiocManager::install(\"GenomicRanges\") } if (!requireNamespace(\"MatrixGenerics\", quietly = TRUE)) {   BiocManager::install(\"MatrixGenerics\") } if (!requireNamespace(\"EnrichedHeatmap\", quietly = TRUE)) {   BiocManager::install(\"EnrichedHeatmap\") }  # Once installed then load the required libraries  library(rtracklayer) library(purrr) library(GenomicRanges) library(MatrixGenerics) library(EnrichedHeatmap)"},{"path":"/articles/matList_example.html","id":"usage","dir":"Articles","previous_headings":"Detailed Example of matList","what":"Usage","title":"Detailed Example of matList Usage","text":"example going use 3 unstranded bigWig files. also going extend regions 20b either side set window size 1. Import bigWig files using importBWlist function Import region file Specify arguments desire create matrices using matList function","code":"# Define our file paths and names for the importBWlist() function bw_file_paths <- c(\"path/to/sample1.bw\", \"path/to/sample2.bw\", \"path/to/treatment.bw\") sample_names <- c(\"Sample1\", \"Sample2\", \"Treatment\")  # Import our bigWig files using the importBWlist function() imported_bw <- importBWlist(bwf = bw_file_paths, names = sample_names) # Import the .bed file as a GRanges object regions <- readBed(path/to/regions.bed) # Generate matrices using the matList() function matl <- matList(   bwf = imported_bw,    names = names(imported_bw),    grl = list(\"regions\" = regions),    extend = 20,    w = 1,    strand = \"no\"   )"},{"path":"/articles/mplot_example.html","id":"detailed-example-of-mplot","dir":"Articles","previous_headings":"","what":"Detailed Example of mplot","title":"Detailed Example of mplot Usage","text":"vignette provides detailed example use mplot function generate average profile plot list matrices generated via matList function. range customisation options available alter output. function leverages ggplot2, dplyr, tidyr, purrr, stringr, rlang, matrixStats packages intepret matrices produces matList function generate accurate average profile plot.","code":""},{"path":"/articles/mplot_example.html","id":"prerequisites","dir":"Articles","previous_headings":"Detailed Example of mplot","what":"Prerequisites","title":"Detailed Example of mplot Usage","text":"begin, ensure necessary packages installed loaded:","code":"if (!requireNamespace(\"tidyr\", quietly = TRUE)) {   install.packages(\"tidyr\") } if (!requireNamespace(\"ggplot2\", quietly = TRUE)) {   install.packages(\"ggplot2\") } if (!requireNamespace(\"stringr\", quietly = TRUE)) {   install.packages(\"stringr\") } if (!requireNamespace(\"rlang\", quietly = TRUE)) {   install.packages(\"rlang\") } if (!requireNamespace(\"dplyr\", quietly = TRUE)) {   install.packages(\"dplyr\") } if (!requireNamespace(\"matrixStats\", quietly = TRUE)) {   install.packages(\"matrixStats\") } if (!requireNamespace(\"purrr\", quietly = TRUE)) {   install.packages(\"purrr\") }   # Once installed then load the required libraries  library(tidyr) library(ggplot2) library(stringr) library(rlang) library(dplyr) library(matrixStats) library(purrr)"},{"path":"/articles/mplot_example.html","id":"usage","dir":"Articles","previous_headings":"Detailed Example of mplot","what":"Usage","title":"Detailed Example of mplot Usage","text":"case going take list matrices called “matrixlist” generated matList function use generate average profile plot using plotggplotHeatmap function range customisation options. Define colour palette average profile plot Creating average profile plot changing title, axis labels, line transparency, including error","code":"# Using a colour palette from the RColorBrewer package pal = c(RColorBrewer::brewer.pal(n = 9,name = \"Set1\")) average_profile <- mplot(   matl = matrixlist,    colmap = pal,    title = \"Average Profile Example\",    unit = \"Y-axis value\",    feature = \"X-axis value\",    alpha = 0.7,    error = TRUE   )"},{"path":"/articles/plotggplotHeatmap_example.html","id":"detailed-example-of-plotggplotheatmap","dir":"Articles","previous_headings":"","what":"Detailed Example of plotggplotHeatmap","title":"Detailed Example of plotggplotHeatmap Usage","text":"vignette provides detailed example use plotggplotHeatmap function create list ggplot heatmap objects list matrices generated matList function. function leverages tidyr, dplyr, ggplot2, stats, patchwork, viridis, RColorBrewer packages interpret matrix data produce heatmap visualisations range customisation options","code":""},{"path":"/articles/plotggplotHeatmap_example.html","id":"prerequisites","dir":"Articles","previous_headings":"Detailed Example of plotggplotHeatmap","what":"Prerequisites","title":"Detailed Example of plotggplotHeatmap Usage","text":"begin, ensure necessary packages installed loaded:","code":"if (!requireNamespace(\"tidyr\", quietly = TRUE)) {   install.packages(\"tidyr\") } if (!requireNamespace(\"ggplot2\", quietly = TRUE)) {   install.packages(\"ggplot2\") } if (!requireNamespace(\"stats\", quietly = TRUE)) {   install.packages(\"stats\") } if (!requireNamespace(\"RColorBrewer\", quietly = TRUE)) {   install.packages(\"RColorBrewer\") } if (!requireNamespace(\"viridis\", quietly = TRUE)) {   install.packages(\"viridis\") } if (!requireNamespace(\"patchwork\", quietly = TRUE)) {   install.packages(\"patchwork\") }   # Once installed then load the required libraries  library(tidyr) library(ggplot2) library(stats) library(RColorBrewer) library(viridis) library(patchwork)"},{"path":"/articles/plotggplotHeatmap_example.html","id":"usage","dir":"Articles","previous_headings":"Detailed Example of plotggplotHeatmap","what":"Usage","title":"Detailed Example of plotggplotHeatmap Usage","text":"case going take list matrices called “matrixlist” generated matList function use generate heatmaps using plotggplotHeatmap function Selecting window sizes plotting. case give 50 windows upstream flank, 100 full gene, 50 downstream flank Using plotggplotHeatmap create heatmaps using following customisation options: (1) Want average profile (2) Viridis colour palette (3) log2 transformation (4) Break lines heatmap","code":"# Specify the window sizes windows <- c(\"Upstream\" = 50, \"Gene\" = 100, \"Downstream\" = 50) # Generating our heatmap list heatmaps <- plotggplotHeatmap(   matl = matrixlist,   wins = windows,   average_profile = TRUE,   colour_palette = \"viridis\",   log2 = TRUE,   dottedlines = TRUE   )"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Zack Swales. Maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Swales Z (2025). seqEasyFunctions: Functions used within seqEasy application. R package version 0.1.0.","code":"@Manual{,   title = {seqEasyFunctions: Functions used within the seqEasy application},   author = {Zack Swales},   year = {2025},   note = {R package version 0.1.0}, }"},{"path":[]},{"path":"/index.html","id":"id_-overview","dir":"","previous_headings":"","what":"🌍 Overview","title":"Welcome to seqEasyFunctions","text":"seqEasyFunctions R package containing functions developed seqEasy application external use.","code":""},{"path":"/index.html","id":"id_-installation","dir":"","previous_headings":"","what":"🧰 Installation","title":"Welcome to seqEasyFunctions","text":"install seqEasyFunctions, can use devtools package install directly GitHub. Run following code R console:","code":"# Install devtools if you don't have it install.packages(\"devtools\")  # Install seqEasyFunctions from GitHub devtools::install_github(\"zackswales/seqEasyFunctions\")"},{"path":"/index.html","id":"id_-loading-the-package","dir":"","previous_headings":"","what":"📦 Loading the package","title":"Welcome to seqEasyFunctions","text":"installed package, run following code load .","code":"# Load the package library(seqEasyFunctions)"},{"path":"/reference/getFeature.html","id":null,"dir":"Reference","previous_headings":"","what":"Get genomic ranges based on specified features and flanking regions. — getFeature","title":"Get genomic ranges based on specified features and flanking regions. — getFeature","text":"function takes GRanges object extracts creates new genomic ranges based specified start end features (TSS, TES, Exon) flanking regions. allows specifying exon numbers boundaries precise range definition.","code":""},{"path":"/reference/getFeature.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get genomic ranges based on specified features and flanking regions. — getFeature","text":"","code":"getFeature(   object,   start_feature = \"TSS\",   start_flank = 0,   start_exon = NULL,   start_exon_boundary = NULL,   start_direction = \"up\",   end_feature = \"TES\",   end_flank = 0,   end_direction = \"down\",   end_exon = NULL,   end_exon_boundary = NULL,   return = \"all\" )"},{"path":"/reference/getFeature.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get genomic ranges based on specified features and flanking regions. — getFeature","text":"object GRanges object containing genomic features (e.g., genes exons). object must metadata columns including 'blockStarts', 'blockSizes', 'blockCount' 'Exon' specified feature. start_feature character string specifying starting feature. Must one \"TSS\" (Transcription Start Site), \"TES\" (Transcription End Site), \"Exon\". Default \"TSS\". start_flank integer indicating number bases flank start_feature. Default 0. start_exon integer specifying exon number use start_feature \"Exon\". start_exon_boundary character string specifying exon boundary use start_feature \"Exon\". Must either \"5prime\" \"3prime\". start_direction character string indicating direction flank relative start_feature. Must either \"\" (upstream) \"\" (downstream). Default \"\". end_feature character string specifying ending feature. Must one \"TSS\", \"TES\", \"Exon\". Default \"TES\". end_flank integer indicating number bases flank end_feature. Default 0. end_direction character string indicating direction flank relative end_feature. Must either \"\" (upstream) \"\" (downstream). Default \"\". end_exon integer specifying exon number use end_feature \"Exon\". end_exon_boundary character string specifying exon boundary use end_feature \"Exon\". Must either \"5prime\" \"3prime\". return character string specifying ranges return. Must one \"\" (plus minus strand ranges), \"plus\" (plus strand ranges), \"minus\" (minus strand ranges). Default \"\".","code":""},{"path":"/reference/getFeature.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get genomic ranges based on specified features and flanking regions. — getFeature","text":"GRanges object containing extracted created genomic ranges.","code":""},{"path":"/reference/getFeature.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get genomic ranges based on specified features and flanking regions. — getFeature","text":"","code":"# Create a dummy GRanges object library(GenomicRanges) #> Loading required package: stats4 #> Loading required package: BiocGenerics #>  #> Attaching package: ‘BiocGenerics’ #> The following objects are masked from ‘package:stats’: #>  #>     IQR, mad, sd, var, xtabs #> The following objects are masked from ‘package:base’: #>  #>     Filter, Find, Map, Position, Reduce, anyDuplicated, aperm, append, #>     as.data.frame, basename, cbind, colnames, dirname, do.call, #>     duplicated, eval, evalq, get, grep, grepl, intersect, is.unsorted, #>     lapply, mapply, match, mget, order, paste, pmax, pmax.int, pmin, #>     pmin.int, rank, rbind, rownames, sapply, setdiff, sort, table, #>     tapply, union, unique, unsplit, which.max, which.min #> Loading required package: S4Vectors #>  #> Attaching package: ‘S4Vectors’ #> The following object is masked from ‘package:utils’: #>  #>     findMatches #> The following objects are masked from ‘package:base’: #>  #>     I, expand.grid, unname #> Loading required package: IRanges #> Loading required package: GenomeInfoDb genes <- GRanges(   seqnames = \"chr1\",   ranges = IRanges(start = c(100, 2000), end = c(1000, 3000)),   strand = c(\"+\", \"-\"),   blockStarts = c(\"0,200,500\", \"0,300\"),   blockSizes = c(\"100,300,500\", \"200,500\"),   blockCount = c(3, 2) )  # Get TSS regions with 100bp upstream flank tss_regions <- getFeature(genes, start_feature = \"TSS\", start_flank = 100) tss_regions #> GRanges object with 2 ranges and 3 metadata columns: #>       seqnames    ranges strand | blockStarts  blockSizes blockCount #>          <Rle> <IRanges>  <Rle> | <character> <character>  <numeric> #>   [1]     chr1 2000-3100      - |       0,300     200,500          2 #>   [2]     chr1    0-1000      + |   0,200,500 100,300,500          3 #>   ------- #>   seqinfo: 1 sequence from an unspecified genome; no seqlengths  # Get regions from TSS to TES gene_bodies <- getFeature(genes, start_feature = \"TSS\", end_feature = \"TES\") gene_bodies #> GRanges object with 2 ranges and 3 metadata columns: #>       seqnames    ranges strand | blockStarts  blockSizes blockCount #>          <Rle> <IRanges>  <Rle> | <character> <character>  <numeric> #>   [1]     chr1 2000-3000      - |       0,300     200,500          2 #>   [2]     chr1  100-1000      + |   0,200,500 100,300,500          3 #>   ------- #>   seqinfo: 1 sequence from an unspecified genome; no seqlengths  # Get regions around the 2nd exon start exon2_start <- getFeature(genes, start_feature = \"Exon\", start_exon = 2,                            start_exon_boundary = \"5prime\", start_flank = 50) exon2_start #> GRanges object with 2 ranges and 3 metadata columns: #>       seqnames    ranges strand | blockStarts  blockSizes blockCount #>          <Rle> <IRanges>  <Rle> | <character> <character>  <numeric> #>   [1]     chr1 2000-2250      - |       0,300     200,500          2 #>   [2]     chr1  250-1000      + |   0,200,500 100,300,500          3 #>   ------- #>   seqinfo: 1 sequence from an unspecified genome; no seqlengths  # Get regions spanning the 1st to the 2nd exon exon1_to_2 <- getFeature(genes, start_feature = \"Exon\", start_exon = 1,                           start_exon_boundary = \"5prime\",                           end_feature = \"Exon\", end_exon = 2,                           end_exon_boundary = \"3prime\") exon1_to_2 #> GRanges object with 2 ranges and 3 metadata columns: #>       seqnames    ranges strand | blockStarts  blockSizes blockCount #>          <Rle> <IRanges>  <Rle> | <character> <character>  <numeric> #>   [1]     chr1 2000-2800      - |       0,300     200,500          2 #>   [2]     chr1   100-600      + |   0,200,500 100,300,500          3 #>   ------- #>   seqinfo: 1 sequence from an unspecified genome; no seqlengths"},{"path":"/reference/hmList.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a list of enriched heatmaps from a list of matrices. — hmList","title":"Generate a list of enriched heatmaps from a list of matrices. — hmList","text":"function takes list matrices (typically output matList) generates list enriched heatmaps using EnrichedHeatmap package. allows customization color schemes, row splitting, column features, quantile-based scaling, row name display, window labels, y-axis limits, summarisation enrichment, axis labels, row clustering, log2 transformation.","code":""},{"path":"/reference/hmList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a list of enriched heatmaps from a list of matrices. — hmList","text":"","code":"hmList(   matl,   wins,   split = NULL,   split_cols,   max_quantile = 0.99,   min_quantile = 0,   col_fun = \"red\",   show_row_names = TRUE,   win_labels = NULL,   ylim = NULL,   summarise_by = \"mean\",   axis_labels = \"\",   row_km = 1,   log2 = FALSE )"},{"path":"/reference/hmList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a list of enriched heatmaps from a list of matrices. — hmList","text":"matl named list matrices, matrix represents signal intensity genomic regions (e.g., output matList). wins named integer vector specifying number bins (windows) matrices matl normalized feature type. names correspond feature types (e.g., c(\"Gene\" = 10)). split optional data.frame used split rows heatmaps. column data frame define way split rows. split_cols named list specifying colors levels splitting variable provided split. names list correspond column names data frame used splitting. max_quantile numeric value 0 1 specifying upper quantile scaling color map. Values quantile capped. min_quantile numeric value 0 1 specifying lower quantile scaling color map. Values quantile capped. col_fun character string specifying color function use. Options include \"red\" (white red), \"bl2rd\" (blue white red), \"red0\" (white light red dark red starting 0). Alternatively, custom color function generated circlize::colorRamp2 can provided. show_row_names logical value indicating whether display row names heatmaps. win_labels optional character vector specifying labels feature windows displayed top annotation. NULL, names wins used. ylim optional numeric vector length 2 specifying y-axis limits enrichment profile top annotation. NULL, limits automatically determined. summarise_by character string specifying function summarise rows enrichment profile top annotation (e.g., \"mean\", \"median\"). axis_labels character string specifying label x-axis enrichment profile top annotation. row_km integer specifying number clusters perform k-means clustering rows. NULL 1, clustering performed. log2 logical value indicating whether apply log2 transformation (pseudocount 1) matrices matl plotting.","code":""},{"path":"/reference/hmList.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a list of enriched heatmaps from a list of matrices. — hmList","text":"list EnrichedHeatmap objects, one matrix input matl.","code":""},{"path":"/reference/hmList.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a list of enriched heatmaps from a list of matrices. — hmList","text":"","code":"# Assuming you have generated a list of matrices using matList() if (FALSE) { # \\dontrun{ # Create a dummy matrix list for demonstration mat_list <- list(   sample1 = matrix(rnorm(100), nrow = 20),   sample2 = matrix(rnorm(100), nrow = 20) ) wins_info <- c(\"FeatureA\" = 5)  # Generate a list of enriched heatmaps hm_list <- hmList(matl = mat_list, wins = wins_info)  # Generate heatmaps with row splitting and custom colors split_df <- data.frame(group = factor(rep(c(\"Group1\", \"Group2\"), each = 10))) split_colors <- list(\"group\" = c(\"Group1\" = \"blue\", \"Group2\" = \"green\")) hm_list_split <- hmList(matl = mat_list, wins = wins_info, split = split_df,                         split_cols = split_colors) } # }"},{"path":"/reference/importBWlist.html","id":null,"dir":"Reference","previous_headings":"","what":"Import a list of BigWig files. — importBWlist","title":"Import a list of BigWig files. — importBWlist","text":"function imports multiple BigWig files list rtracklayer::BigWigFile objects.","code":""},{"path":"/reference/importBWlist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Import a list of BigWig files. — importBWlist","text":"","code":"importBWlist(bwf, names, selection = NULL)"},{"path":"/reference/importBWlist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Import a list of BigWig files. — importBWlist","text":"bwf character vector specifying paths BigWig files. names character vector specifying names assign elements resulting list. selection optional GRanges RangesList object specifying genomic regions import BigWig file. NULL (default), entire file imported.","code":""},{"path":"/reference/importBWlist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Import a list of BigWig files. — importBWlist","text":"named list rtracklayer::BigWigFile objects.","code":""},{"path":"/reference/importBWlist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Import a list of BigWig files. — importBWlist","text":"","code":"# Assuming you have BigWig files named \"file1.bw\" and \"file2.bw\" # and a GRanges object named 'regions' if (FALSE) { # \\dontrun{ bigwig_files <- c(\"file1.bw\", \"file2.bw\") file_names <- c(\"sample1\", \"sample2\")  # Import the entire files bw_list_full <- importBWlist(bigwig_files, file_names)  # Import only the specified regions bw_list_selected <- importBWlist(bigwig_files, file_names, selection = regions) } # }"},{"path":"/reference/matList.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a list of normalized matrices from BigWig files over genomic regions. — matList","title":"Generate a list of normalized matrices from BigWig files over genomic regions. — matList","text":"function takes forward reverse strand BigWig files list genomic region sets, returns list normalized matrices representing signal intensities regions. supports flexible control binning, strand handling, normalization mode, smoothing, matrix represents target regions.","code":""},{"path":"/reference/matList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a list of normalized matrices from BigWig files over genomic regions. — matList","text":"","code":"matList(   bwf,   bwr,   names,   grl,   wins = list(Gene = 10),   mode = \"coverage\",   output = \"norm.matrix\",   strand = \"rev\",   smooth = FALSE,   extend = 0,   w,   include_target = TRUE,   target_ratio = 0.5,   k = 10,   keep )"},{"path":"/reference/matList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a list of normalized matrices from BigWig files over genomic regions. — matList","text":"bwf list rtracklayer::BigWigFile objects forward strand data (e.g., output importBWlist). bwr list rtracklayer::BigWigFile objects reverse strand data. names character vector specifying names assign resulting list matrices. grl GRangesList element defines set genomic regions (e.g., genes, TSSs). wins named list specifying number bins (windows) region type grl. multiple entries provided, features assumed combined. mode Character string specifying normalization mode normalizeToMatrix, \"coverage\" \"mean\". output Output format: either \"norm.matrix\" (default) return normalizedMatrix objects, \"matrix\" return base R matrices. strand Strand specificity: \"rev\" (default) reverse alignment, \"\" forward, \"\" ignore strand. smooth Logical; TRUE, applies smoothing normalizeToMatrix. extend Integer; number base pairs extend around region. w Optional integer; smoothing window size (used smooth = TRUE). include_target Logical; whether include target region matrix. target_ratio Numeric 0 1; controls fraction matrix allocated target region. k Integer; number bins matrix (used wins length 1). keep (Unused) Optional parameter placeholder future development.","code":""},{"path":"/reference/matList.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a list of normalized matrices from BigWig files over genomic regions. — matList","text":"named list matrices, either EnrichedHeatmap::normalizedMatrix objects base R numeric matrices, depending output parameter.","code":""},{"path":"/reference/matList.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a list of normalized matrices from BigWig files over genomic regions. — matList","text":"","code":"if (FALSE) { # \\dontrun{ # Load BigWig files and genomic regions forward_bw <- importBWlist(c(\"sample1.f.bw\", \"sample2.f.bw\"), c(\"sample1\", \"sample2\")) reverse_bw <- importBWlist(c(\"sample1.r.bw\", \"sample2.r.bw\"), c(\"sample1\", \"sample2\"))  gene_grl <- GRangesList(   gene1 = GRanges(\"chr1\", IRanges(1000, 2000), strand = \"+\", name = \"gene1_a\"),   gene2 = GRanges(\"chr1\", IRanges(3000, 4000), strand = \"-\", name = \"gene2_b\") )  # Create normalized matrix list with 20 bins matList(   bwf = forward_bw,   bwr = reverse_bw,   names = c(\"sample1\", \"sample2\"),   grl = gene_grl,   wins = list(\"Gene\" = 20) ) } # }"},{"path":"/reference/mplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a metaplot from a list of matrices. — mplot","title":"Generate a metaplot from a list of matrices. — mplot","text":"function takes list matrices (e.g., coverage values across genomic regions) generates metaplot, optionally comparing control list matrices. provides flexibility grouping, faceting, displaying error bars.","code":""},{"path":"/reference/mplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a metaplot from a list of matrices. — mplot","text":"","code":"mplot(   matl,   matlc = NULL,   feature = \"Gene\",   unit = \"Coverage (BPM)\",   title = \"Gene metaplot\",   breaks = c(0, 20, 60, 80),   labels = c(\"-200\", \"TSS\", \"TTS\", \"+200\"),   colmap,   split = NULL,   facet = NULL,   angle = 0,   strip_fill = \"white\",   facet_scale = \"fixed\",   max_quantile = 1,   min_quantile = 0,   pseudo = 1,   alpha = 1,   linewidth = 0.5,   error = F,   alpha_error = 0.5,   facet_nrow = 2,   facet_type = \"wrap\",   facet_independent = F,   summarise_by = \"mean\",   colour_by = \"Sample\" )"},{"path":"/reference/mplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a metaplot from a list of matrices. — mplot","text":"matl list matrices, matrix represents sample rows correspond genomic positions. matlc optional list control matrices dimensions structure `matl`. provided, function plot log2 ratio `matl` `matlc`. Defaults `NULL`. feature string specifying label x-axis (e.g., \"Gene\", \"Transcript\"). Defaults \"Gene\". unit string specifying label y-axis (e.g., \"Coverage (BPM)\", \"Signal Intensity\"). Defaults \"Coverage (BPM)\". title string specifying title plot. Defaults \"Gene metaplot\". breaks numeric vector specifying positions x-axis breaks. Defaults `c(0, 20, 60, 80)`. labels character vector specifying labels x-axis breaks. length `labels` must length `breaks`. Defaults `c(\"-200\", \"TSS\", \"TTS\", \"+200\")`. colmap named vector colors use different groups (defined `colour_by`). names vector correspond unique values column specified `colour_by`. split optional data frame whose rownames correspond rownames matrices `matl`. data frame can contain columns group data plotting (e.g., experimental condition). Defaults `NULL`. facet optional string vector strings specifying column(s) `split` use faceting plot. Defaults `NULL`. angle numeric value specifying angle (degrees) x-axis labels. Defaults `0`. strip_fill string specifying fill color facet strip background. Defaults \"white\". facet_scale string specifying whether scales fixed (\"fixed\"), free (\"free\"), free x direction (\"free_x\"), free y direction (\"free_y\"). Passed `facet_wrap` `facet_grid2`. Defaults \"fixed\". max_quantile numeric value 0 1 specifying upper quantile use outlier removal calculating mean sum. Defaults `1` (upper outlier removal). min_quantile numeric value 0 1 specifying lower quantile use outlier removal calculating mean sum. Defaults `0` (lower outlier removal). pseudo numeric value added `matl` `matlc` log2 transformation avoid taking logarithm zero. used `matlc` provided. Defaults `1`. alpha numeric value 0 1 specifying alpha (transparency) lines. Defaults `1` (fully opaque). linewidth numeric value specifying width lines. Defaults `0.5`. error logical value indicating whether plot error bars (standard error mean). applicable `summarise_by = \"mean\"`. Defaults `FALSE`. alpha_error numeric value 0 1 specifying alpha (transparency) error bar ribbons. Defaults `0.5`. facet_nrow integer specifying number rows use `facet_type = \"wrap\"`. Defaults `2`. facet_type string specifying faceting type. Can \"wrap\" (using `facet_wrap`) \"grid\" (using `facet_grid2`). Defaults \"wrap\". facet_independent logical value indicating whether scales independent panel `facet_grid2`. used `facet_type = \"grid\"`. Defaults `FALSE`. summarise_by string specifying summarise data within groups. Can \"mean\" \"sum\". Defaults \"mean\". colour_by string specifying column name combined data frame (`split` provided) use coloring lines. Defaults \"Sample\".","code":""},{"path":"/reference/mplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a metaplot from a list of matrices. — mplot","text":"ggplot object representing metaplot.","code":""},{"path":"/reference/mplot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a metaplot from a list of matrices. — mplot","text":"","code":"# Create some dummy data set.seed(123) mat1 <- matrix(rnorm(100), nrow = 10) mat2 <- matrix(rnorm(100, 0.5), nrow = 10) matl_example <- list(sample1 = mat1, sample2 = mat2) rownames(mat1) <- rownames(mat2) <- paste0(\"gene\", 1:10)  # Basic metaplot mplot(matl_example) #> Error in bind_rows(imap(ml, ~rownames_to_column(mutate(as.data.frame(.x),     Sample = .y), \"name\"))): could not find function \"bind_rows\"  # Metaplot with custom title and axis labels mplot(matl_example, title = \"My Metaplot\", feature = \"Region\", unit = \"Signal\") #> Error in bind_rows(imap(ml, ~rownames_to_column(mutate(as.data.frame(.x),     Sample = .y), \"name\"))): could not find function \"bind_rows\"  # Metaplot with custom colors col_map <- c(\"sample1\" = \"blue\", \"sample2\" = \"red\") mplot(matl_example, colmap = col_map) #> Error in bind_rows(imap(ml, ~rownames_to_column(mutate(as.data.frame(.x),     Sample = .y), \"name\"))): could not find function \"bind_rows\"  # Add a splitting factor split_df <- data.frame(condition = rep(c(\"A\", \"B\"), each = 5),                        row.names = paste0(\"gene\", 1:10)) mplot(matl_example, split = split_df, colour_by = \"condition\") #> Error in bind_rows(imap(ml, ~rownames_to_column(mutate(as.data.frame(.x),     Sample = .y), \"name\"))): could not find function \"bind_rows\"  # Facet the plot mplot(matl_example, split = split_df, facet = \"condition\") #> Error in bind_rows(imap(ml, ~rownames_to_column(mutate(as.data.frame(.x),     Sample = .y), \"name\"))): could not find function \"bind_rows\"  # Metaplot with control data matlc_example <- list(sample1 = matrix(rnorm(100, 0.1), nrow = 10),                       sample2 = matrix(rnorm(100, 0.2), nrow = 10)) rownames(matlc_example[[1]]) <- rownames(matlc_example[[2]]) <- paste0(\"gene\", 1:10) mplot(matl_example, matlc = matlc_example, unit = \"log2(Treatment/Control)\") #> Error in map2(matl, matlc, ~log2((.x + pseudo)/(.y + pseudo))): could not find function \"map2\"  # Metaplot with error bars mplot(matl_example, error = TRUE) #> Error in bind_rows(imap(ml, ~rownames_to_column(mutate(as.data.frame(.x),     Sample = .y), \"name\"))): could not find function \"bind_rows\""},{"path":"/reference/plotggplotHeatmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a list of ggplot2 heatmaps from a list of matrices. — plotggplotHeatmap","title":"Generate a list of ggplot2 heatmaps from a list of matrices. — plotggplotHeatmap","text":"function takes list matrices (typically output matList) generates list ggplot2 heatmaps, options color palettes, scaling, labels, average profiles, k-means clustering, log2 transformation, dotted lines, row splitting.","code":""},{"path":"/reference/plotggplotHeatmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a list of ggplot2 heatmaps from a list of matrices. — plotggplotHeatmap","text":"","code":"plotggplotHeatmap(   matl,   color_palette = \"red_white\",   zMin = NULL,   zMax = NULL,   xlab = NULL,   ylab = NULL,   fill_label = \"Signal\",   title = NULL,   wins,   break_labels,   average_profile = FALSE,   k_clusters = NULL,   log2 = FALSE,   dottedlines = FALSE,   split = NULL )"},{"path":"/reference/plotggplotHeatmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a list of ggplot2 heatmaps from a list of matrices. — plotggplotHeatmap","text":"matl named list matrices, matrix represents signal intensity genomic regions (e.g., output matList). color_palette character string specifying color palette use (e.g., \"red_white\", \"viridis\", \"magma\", \"inferno\", \"cividis\", \"Blues\", \"Greens\", \"Reds\", \"RdBu\", \"RdYlBu\", \"PuOr\", \"BrBG\"). Alternatively, vector colors custom palette can provided. zMin numeric value specifying minimum value color scale. \"auto\", set 1st percentile values matl. NULL, lower limit enforced function (ggplot2 determine ). zMax numeric value specifying maximum value color scale. \"auto\", set 99th percentile values matl. NULL, upper limit enforced function (ggplot2 determine ). xlab character string specifying label x-axis. ylab character string specifying label y-axis. fill_label character string specifying label fill scale (legend). title optional character string specifying title plot (used average_profile = FALSE). wins named integer vector specifying number bins (windows) matrices matl normalized feature type. names correspond feature types (e.g., c(\"Gene\" = 10)). break_labels character vector specifying labels breaks x-axis. length vector must equal number breaks defined wins plus one (start). average_profile logical value indicating whether include average profile plot heatmap. k_clusters optional integer specifying number clusters k-means clustering rows matrix. provided, heatmap faceted cluster. log2 logical value indicating whether apply log2 transformation (pseudocount 1) matrices matl plotting. dottedlines logical value indicating whether add dotted vertical lines breaks defined wins. split optional data.frame used split rows heatmaps. one column, rownames correspond rownames matrices matl (assumed gene IDs).","code":""},{"path":"/reference/plotggplotHeatmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a list of ggplot2 heatmaps from a list of matrices. — plotggplotHeatmap","text":"single ggplot2 object one matrix provided matl,         otherwise combined ggplot2 object using patchwork.","code":""},{"path":"/reference/plotggplotHeatmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a list of ggplot2 heatmaps from a list of matrices. — plotggplotHeatmap","text":"","code":"# Assuming you have generated a list of matrices using matList() if (FALSE) { # \\dontrun{ # Create a dummy matrix list for demonstration mat_list <- list(   sample1 = matrix(rnorm(100), nrow = 20, dimnames = list(paste0(\"gene\", 1:20))),   sample2 = matrix(rnorm(100), nrow = 20, dimnames = list(paste0(\"gene\", 1:20))) ) wins_info <- c(\"FeatureA\" = 5) break_labs <- c(\"Start\", \"FeatureA\")  # Basic heatmap plotggplotHeatmap(matl = mat_list, wins = wins_info, break_labels = break_labs)  # Heatmap with average profile plotggplotHeatmap(matl = mat_list, wins = wins_info, break_labels = break_labs,                   average_profile = TRUE)  # Heatmap with k-means clustering plotggplotHeatmap(matl = mat_list, wins = wins_info, break_labels = break_labs,                   k_clusters = 2)  # Heatmap with row splitting split_df <- data.frame(group = factor(rep(c(\"Group1\", \"Group2\"), each = 10)),                        row.names = paste0(\"gene\", 1:20)) plotggplotHeatmap(matl = mat_list, wins = wins_info, break_labels = break_labs,                   split = split_df) } # }"}]
